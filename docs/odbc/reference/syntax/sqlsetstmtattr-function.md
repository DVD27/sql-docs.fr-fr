---
title: Fonction SQLSetStmtAttr (fr) Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLSetStmtAttr
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetStmtAttr
helpviewer_keywords:
- SQLSetStmtAttr function [ODBC]
ms.assetid: 7abc5260-733a-48d4-9974-2d1a6a9ea5f6
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: dfbd2144e677d053f6154dfb3a1df1f6c25d9da5
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/14/2020
ms.locfileid: "81287261"
---
# <a name="sqlsetstmtattr-function"></a>Fonction SQLSetStmtAttr
**Conformité**  
 Version introduite: ODBC 3.0 Standards Compliance: ISO 92  
  
 **Résumé**  
 **SQLSetStmtAttr** définit les attributs liés à une déclaration.  
  
> [!NOTE]
>  Pour plus d’informations sur ce que le Gestionnaire de conducteur cartographie cette fonction à quand une application ODBC *3.x* travaille avec un pilote ODBC *2.x,* voir [Mapping Replacement Functions for Backward Compatibility of Applications](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Syntaxe  
  
```cpp  
  
SQLRETURN SQLSetStmtAttr(  
     SQLHSTMT      StatementHandle,  
     SQLINTEGER    Attribute,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    StringLength);  
```  
  
## <a name="arguments"></a>Arguments  
 *StatementHandle (en)*  
 [Entrée] Poignée de déclaration.  
  
 *Attribut*  
 [Entrée] Option à définir, répertoriée dans "Commentaires".  
  
 *ValuePtr*  
 [Entrée] Valeur à associer à *Attribut*. Selon la valeur *d’Attribut*, *ValuePtr* sera l’un des éléments suivants :  
  
-   Une poignée descripteur ODBC.  
  
-   Une valeur SQLUINTEGER.  
  
-   Une valeur SQLULEN.  
  
-   Un pointeur à l’un des éléments suivants:  
  
    -   Une corde de caractère non terminée.  
  
    -   Un tampon binaire.  
  
    -   Une valeur ou un tableau de type SQLLEN, SQLULEN, ou SQLUSMALLINT.  
  
    -   Une valeur définie par le conducteur.  
  
 Si *l’argument d’attribut* est une valeur spécifique au conducteur, *ValuePtr* peut être un intégrateur signé.  
  
 *StringLength (en)*  
 [Entrée] Si *Attribut* est un attribut défini par ODBC et *que ValuePtr* pointe vers une \*chaîne de caractères ou un tampon binaire, cet argument doit être la longueur de *ValuePtr*. Si *Attribut* est un attribut défini par ODBC et *que ValuePtr* est un intégrateur, *StringLength* est ignoré.  
  
 Si *Attribut* est un attribut défini par le conducteur, l’application indique la nature de l’attribut au gestionnaire de conducteur en définissant l’argument *StringLength.* *StringLength* peut avoir les valeurs suivantes :  
  
-   Si *ValuePtr* est un pointeur d’une chaîne de caractères, *stringLength* est la longueur de la chaîne ou SQL_NTS.  
  
-   Si *ValuePtr* est un pointeur à un tampon binaire, alors l’application place le résultat de la SQL_LEN_BINARY_ATTR (*longueur)* macro dans *StringLength*. Cela place une valeur négative dans *StringLength*.  
  
-   Si *ValuePtr* est un pointeur à une valeur autre qu’une chaîne de caractère ou une chaîne binaire, alors *StringLength* devrait avoir la valeur SQL_IS_POINTER.  
  
-   Si *ValuePtr* contient une valeur fixe, *stringLength* est soit SQL_IS_INTEGER ou SQL_IS_UINTEGER, le cas échéant.  
  
## <a name="returns"></a>Retours  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR ou SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Diagnostics  
 Lorsque **SQLSetStmtAttr** retourne SQL_ERROR ou SQL_SUCCESS_WITH_INFO, une valeur SQLSTATE associée peut être obtenue en appelant **SQLGetDiagRec** avec un *HandleType* de SQL_HANDLE_STMT et une *poignée* de *StatementHandle*. Le tableau suivant énumère les valeurs SQLSTATE couramment retournées par **SQLSetStmtAttr** et explique chacune dans le cadre de cette fonction; la notation " (DM)" précède les descriptions des SQLSTATEs retournées par le gestionnaire de conducteur. Le code de retour associé à chaque valeur SQLSTATE est SQL_ERROR, sauf indication contraire.  
  
|SQLSTATE|Error|Description|  
|--------------|-----------|-----------------|  
|01000|Avertissement général|Message d’information spécifique au conducteur. (Les retours de fonction SQL_SUCCESS_WITH_INFO.)|  
|01S02|Valeur de l’option modifiée|Le conducteur n’a pas supporté la valeur spécifiée dans *ValuePtr*, ou la valeur spécifiée dans *ValuePtr* était invalide en raison des conditions de travail de mise en œuvre, de sorte que le conducteur a substitué une valeur similaire. (**SQLGetStmtAttr** peut être appelé pour déterminer la valeur temporairement substituée.) La valeur de remplacement est valide pour le *StatementHandle* jusqu’à ce que le curseur soit fermé, à ce moment-là l’attribut de déclaration revient à sa valeur précédente. Les attributs de l’instruction qui peuvent être modifiés sont les :<br /><br /> SQL_ ATTR_CONCURRENCY SQL_ ATTR_CURSOR_TYPE SQL_ ATTR_KEYSET_SIZE SQL_ ATTR_MAX_LENGTH SQL_ ATTR_MAX_ROWS SQL_ ATTR_QUERY_TIMEOUT SQL_ATTR_ROW_ARRAY_SIZE SQL_ ATTR_SIMULATE_CURSOR<br /><br /> (Les retours de fonction SQL_SUCCESS_WITH_INFO.)|  
|08S01|Défaillance du lien de communication|Le lien de communication entre le conducteur et la source de données à laquelle le conducteur était connecté a échoué avant que la fonction ne termine le traitement.|  
|24 000|État de curseur non valide|*L’attribut* était SQL_ATTR_CONCURRENCY, SQL_ATTR_CURSOR_TYPE, SQL_ATTR_SIMULATE_CURSOR, ou SQL_ATTR_USE_BOOKMARKS, et le curseur était ouvert.|  
|HY000|Erreur générale|Une erreur s’est produite pour laquelle il n’y avait pas de SQLSTATE spécifique et pour laquelle aucun SQLSTATE spécifique à la mise en œuvre n’a été défini. Le message d’erreur retourné par **SQLGetDiagRec** dans le * \** tampon MessageText décrit l’erreur et sa cause.|  
|HY001 (hy001)|Erreur d’allocation de mémoire|Le conducteur n’a pas été en mesure d’allouer la mémoire nécessaire pour soutenir l’exécution ou l’achèvement de la fonction.|  
|HY009|Utilisation invalide du pointeur nul|*L’argument d’attribut* a identifié un attribut de déclaration qui exigeait un attribut de chaîne, et l’argument *de ValuePtr* était un pointeur nul.|  
|HY010|Erreur de séquence de fonction|(DM) Une fonction d’exécution asynchrone a été appelée pour la poignée de connexion qui est associée à la *StatementHandle*. Cette fonction asynchrone était encore en cours d’exécution lorsque la fonction **SQLSetStmtAttr** a été appelée.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, ou **SQLMoreResults** a été appelé pour le *StatementHandle* et retourné SQL_PARAM_DATA_AVAILABLE. Cette fonction a été appelée avant que les données ne soient récupérées pour tous les paramètres en streaming.<br /><br /> (DM) Une fonction d’exécution asynchrone a été appelée pour le *StatementHandle* et était toujours en exécution lorsque cette fonction a été appelée.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, ou **SQLSetPos** a été appelé pour le *StatementHandle* et retourné SQL_NEED_DATA. Cette fonction a été appelée avant que les données ne soient envoyées pour tous les paramètres ou colonnes de données à l’exécution.|  
|HY011 HY011|L’attribut ne peut pas être défini maintenant|*L’attribut* était SQL_ATTR_CONCURRENCY, SQL_ ATTR_CURSOR_TYPE, SQL_ ATTR_SIMULATE_CURSOR, ou SQL_ ATTR_USE_BOOKMARKS, et la déclaration a été préparée.|  
|HY013|Erreur de gestion de la mémoire|L’appel de fonction n’a pas pu être traité parce que les objets de mémoire sous-jacents n’ont pas pu être consultés, peut-être en raison de conditions de mémoire basse.|  
|HY017|Utilisation invalide d’une poignée descripteur automatiquement allouée|(DM) *L’argument de l’attribut* était SQL_ATTR_IMP_ROW_DESC ou SQL_ATTR_IMP_PARAM_DESC.<br /><br /> (DM) *L’argument d’attribut* était SQL_ATTR_APP_ROW_DESC ou SQL_ATTR_APP_PARAM_DESC, et la valeur dans *ValuePtr* était une poignée descripteur implicitement attribuée autre que la poignée initialement allouée pour l’ARD ou la DPA.|  
|HY024|Valeur d’attribut invalide|Compte tenu de la valeur *d’attribut* spécifiée, une valeur invalide a été spécifiée dans *ValuePtr*. (Le gestionnaire de conducteur retourne ce SQLSTATE uniquement pour les attributs de connexion et de déclaration qui acceptent un ensemble discret de valeurs, telles que SQL_ATTR_ACCESS_MODE ou SQL_ ATTR_ASYNC_ENABLE. Pour tous les autres attributs de connexion et de relevé, le conducteur doit vérifier la valeur spécifiée dans *ValuePtr*.)<br /><br /> *L’argument d’attribut* était SQL_ATTR_APP_ROW_DESC ou SQL_ATTR_APP_PARAM_DESC, et *ValuePtr* était une poignée descripteur explicitement attribuée qui n’est pas sur le même lien que l’argument *de StatementHandle.*|  
|HY090 HY090|Longueur invalide de ficelle ou de tampon|(DM) * \*ValuePtr* est une chaîne de caractères, et *l’argument StringLength* était inférieur à 0, mais n’était pas SQL_NTS.|  
|HY092 HY092|Identification d’attribut/option invalide|(DM) La valeur spécifiée pour l’argument *Attribut* n’était pas valide pour la version d’ODBC prise en charge par le conducteur.<br /><br /> (DM) La valeur spécifiée pour l’argument *Attribut* était un attribut de lecture seulement.|  
|HY117|La connexion est suspendue en raison d’un état de transaction inconnu. Seules les fonctions de déconnexion et de lecture seulement sont autorisées.|(DM) Pour plus d’informations sur l’état suspendu, voir [SQLEndTran Fonction](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Fonctionnalité facultative non implémentée|La valeur spécifiée pour l’argument *Attribut* était un attribut valide de déclaration ODBC pour la version d’ODBC soutenue par le conducteur mais n’était pas pris en charge par le conducteur.<br /><br /> *L’argument d’Attribut* était SQL_ATTR_ASYNC_ENABLE, et un appel à **SQLGetInfo** avec un *InfoType* de SQL_ASYNC_MODE retourne SQL_AM_CONNECTION.<br /><br /> *L’argument d’attribut* était SQL_ATTR_ENABLE_AUTO_IPD, et la valeur de l’attribut de connexion SQL_ATTR_AUTO_IPD était SQL_FALSE.|  
|HYT01 (HYT01)|Délai de connexion expiré|La période de délai de connexion a expiré avant que la source de données ne réponde à la demande. La période de délai de connexion est définie par **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Le conducteur ne prend pas en charge cette fonction|(DM) Le conducteur associé au *StatementHandle* ne prend pas en charge la fonction.|  
|S1118|Le conducteur ne prend pas en charge la notification asynchrone|Si vous appelez **SQLSetStmtAttr** pour régler SQL_ATTR_ASYNC_STMT_EVENT; notification asynchrone n’est pas pris en charge par le conducteur.|  
  
## <a name="comments"></a>Commentaires  
 Les attributs de déclaration pour une déclaration restent en vigueur jusqu’à ce qu’ils soient modifiés par un autre appel à **SQLSetStmtAttr** ou jusqu’à ce que la déclaration soit abandonnée en appelant **SQLFreeHandle**. Appeler **SQLFreeStmt** avec l’option SQL_CLOSE, SQL_UNBIND ou SQL_RESET_PARAMS ne réinitialise pas les attributs de déclaration.  
  
 Certains attributs de déclaration prennent en charge la substitution d’une valeur similaire si la source de données ne prend pas en charge la valeur spécifiée dans *ValuePtr*. Dans de tels cas, le conducteur retourne SQL_SUCCESS_WITH_INFO et SQLSTATE 01S02 (valeur d’option modifiée). Par exemple, si *l’attribut* est SQL_ATTR_CONCURRENCY et *que ValuePtr* est SQL_CONCUR_ROWVER, et si la source de données ne prend pas en charge cela, le conducteur supplée SQL_CONCUR_VALUES et renvoie SQL_SUCCESS_WITH_INFO. Pour déterminer la valeur substituée, une application appelle **SQLGetStmtAttr**.  
  
 Le format d’information défini avec *ValuePtr* dépend de *l’attribut*spécifié . **SQLSetStmtAttr** accepte l’information d’attribut dans l’un des deux formats différents : une chaîne de caractères ou une valeur d’intégrateur. Le format de chacun est noté dans la description de l’attribut. Ce format s’applique aux informations retournées pour chaque attribut dans **SQLGetStmtAttr**. Les chaînes de caractères soulignées par l’argument *ValuePtr* de **SQLSetStmtAttr** ont une longueur de *StringLength*.  
  
> [!NOTE]
>  La possibilité de définir les attributs de déclaration au niveau de connexion en appelant **SQLSetConnectAttr** a été dépréciée dans ODBC *3.x*. Les applications ODBC *3.x* ne doivent jamais définir les attributs de l’instruction au niveau de connexion. Les attributs de relevé ODBC *3.x* ne peuvent pas être définis au niveau de connexion, à l’exception des attributs SQL_ATTR_METADATA_ID et SQL_ATTR_ASYNC_ENABLE, qui sont à la fois des attributs de connexion et des attributs de déclaration, et peuvent être définis au niveau de connexion ou au niveau de l’instruction.  
> 
> [!NOTE]
>  Les pilotes ODBC *3.x* n’ont besoin que de prendre en charge cette fonctionnalité s’ils doivent travailler avec des applications ODBC *2.x* qui fixent les options de relevé ODBC *2.x* au niveau de connexion. Pour plus d’informations, voir « Définir les options d’énoncés sur le niveau de connexion » dans [la cartographie SQLSetConnectOption](../../../odbc/reference/appendixes/sqlsetconnectoption-mapping.md) dans l’annexe G : Lignes directrices du conducteur pour la compatibilité vers l’arrière.  
  
## <a name="statement-attributes-that-set-descriptor-fields"></a>Attributs de déclaration qui fixent des champs descripteur  
 De nombreux attributs de déclaration correspondent à un champ d’en-tête d’un descripteur. La définition de ces attributs aboutit en fait à l’établissement des champs descripteur. Réglage des champs par un appel à **SQLSetStmtAttr** plutôt qu’à **SQLSetDescField** a l’avantage qu’une poignée descripteur n’a pas besoin d’être obtenue pour l’appel de fonction.  
  
> [!CAUTION]  
>  Appeler **SQLSetStmtAttr** pour une déclaration peut affecter d’autres déclarations. Cela se produit lorsque la DPA ou l’ARD associée à l’instruction est explicitement attribuée et est également associée à d’autres déclarations. Étant donné que **SQLSetStmtAttr** modifie la DPA ou l’ARD, les modifications s’appliquent à toutes les déclarations auxquelles ce descripteur est associé. Si ce n’est pas le comportement requis, l’application doit dissocier ce descripteur des autres déclarations (en appelant **SQLSetStmtAttr** pour définir le champ SQL_ATTR_APP_ROW_DESC ou SQL_ATTR_APP_PARAM_DESC à une poignée descripteur différente) avant d’appeler **SQLSetStmtAttr** à nouveau.  
  
 Lorsqu’un champ descripteur est défini à la suite de l’attribution de l’énoncé correspondant, le champ n’est défini que pour les descripteurs applicables qui sont actuellement associés à la déclaration identifiée par *l’argument de StatementHandle,* et le paramètre d’attribut n’affecte aucun descripteur qui pourrait être associé à cette déclaration à l’avenir. Lorsqu’un champ descripteur qui est également un attribut de déclaration est défini par un appel à **SQLSetDescField**, l’attribut de déclaration correspondante est défini. Si un descripteur explicitement attribué est dissocié d’une déclaration, un attribut de déclaration qui correspond à un champ d’en-tête reviendra à la valeur du champ dans le descripteur implicitement attribué.  
  
 Lorsqu’une déclaration est attribuée (voir [SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)), quatre poignées descripteur sont automatiquement attribuées et associées à l’énoncé. Les poignées descripteur explicitement attribuées peuvent être associées à la déclaration en appelant **SQLAllocHandle** avec un *fHandleType* de SQL_HANDLE_DESC d’allouer une poignée descripteur, puis en appelant **SQLSetStmtAttr** pour associer la poignée descripteur à la déclaration.  
  
 Les attributs de l’instruction dans le tableau suivant correspondent aux champs d’en-tête descripteur.  
  
|Attribut d’énoncé|Champ d’en-tête|Desc.|  
|-------------------------|------------------|-----------|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|APD|  
|SQL_ATTR_PARAM_BIND_TYPE|SQL_DESC_BIND_TYPE|APD|  
|SQL_ATTR_PARAM_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|APD|  
|SQL_ATTR_PARAM_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IPD|  
|SQL_ATTR_PARAMS_PROCESSED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IPD|  
|SQL_ATTR_PARAMSET_SIZE|SQL_DESC_ARRAY_SIZE|APD|  
|SQL_ATTR_ROW_ARRAY_SIZE|SQL_DESC_ARRAY_SIZE|Ard|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|Ard|  
|SQL_ATTR_ROW_BIND_TYPE|SQL_DESC_BIND_TYPE|Ard|  
|SQL_ATTR_ROW_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|Ard|  
|SQL_ATTR_ROW_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|Ird|  
|SQL_ATTR_ROWS_FETCHED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|Ird|  
  
## <a name="statement-attributes"></a>Attributs d'instruction  
 Les attributs actuellement définis et la version de l’ODBC dans laquelle ils ont été introduits sont indiqués dans le tableau suivant; on s’attend à ce que davantage d’attributs soient définis par les conducteurs pour tirer parti de différentes sources de données. Une gamme d’attributs est réservée par ODBC; les développeurs de pilotes doivent réserver des valeurs pour leur propre utilisation spécifique au conducteur de Open Group. Pour plus d’informations, consultez [les types de données spécifiques au conducteur, les types descripteurs, les types d’information, les types de diagnostic et les attributs](../../../odbc/reference/develop-app/driver-specific-data-types-descriptor-information-diagnostic.md).  
  
|Attribut|*Contenu ValuePtr*|  
|---------------|-------------------------|  
|SQL_ATTR_APP_PARAM_DESC (ODBC 3.0)|La poignée à l’APD pour les appels ultérieurs à **SQLExecute** et **SQLExecDirect** sur la poignée de déclaration. La valeur initiale de cet attribut est le descripteur implicitement attribué lorsque l’énoncé a été initialement attribué. Si la valeur de cet attribut est définie pour SQL_NULL_DESC ou la poignée initialement allouée au descripteur, une poignée APD explicitement attribuée qui était auparavant associée à la poignée de déclaration est dissociée de celui-ci et la poignée de déclaration revient à la poignée DE LAD implicitement allouée.<br /><br /> Cet attribut ne peut pas être réglé sur une poignée descripteur qui a été implicitement attribuée à une autre déclaration ou à une autre poignée descripteur qui a été implicitement fixée sur la même déclaration; les poignées descripteur implicitement attribuées ne peuvent pas être associées à plus d’une déclaration ou à une poignée descripteur.|  
|SQL_ATTR_APP_ROW_DESC (ODBC 3.0)|La poignée à l’ARD pour les allers de la suite sur la poignée de déclaration. La valeur initiale de cet attribut est le descripteur implicitement attribué lorsque l’énoncé a été initialement attribué. Si la valeur de cet attribut est définie pour SQL_NULL_DESC ou la poignée initialement allouée au descripteur, une poignée ARD explicitement attribuée qui était auparavant associée à la poignée de déclaration est dissociée de celui-ci et la poignée de déclaration revient à la poignée ARD implicitement allouée.<br /><br /> Cet attribut ne peut pas être réglé sur une poignée descripteur qui a été implicitement attribuée à une autre déclaration ou à une autre poignée descripteur qui a été implicitement fixée sur la même déclaration; les poignées descripteur implicitement attribuées ne peuvent pas être associées à plus d’une déclaration ou à une poignée descripteur.|  
|SQL_ATTR_ASYNC_ENABLE (ODBC 1.0)|Une valeur SQLULEN qui précise si une fonction appelée avec la déclaration spécifiée est exécutée asynchrone :<br /><br /> SQL_ASYNC_ENABLE_OFF - Niveau de déclaration désactivable support d’exécution asynchrone (le défaut).<br /><br /> SQL_ASYNC_ENABLE_ON - Activez le niveau d’exécution asynchrone de niveau d’instruction.<br /><br /> Pour plus d’informations, voir [Asynchrone Execution (Méthode de sondage)](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md).<br /><br /> Pour les conducteurs ayant un niveau d’exécution asynchrone de niveau de déclaration, l’attribut de déclaration SQL_ATTR_ASYNC_ENABLE est lu seulement. Sa valeur est la même que la valeur de l’attribut de niveau de connexion avec le même nom au moment où la poignée de déclaration a été attribuée.<br /><br /> Appeler **SQLSetStmtAttr** pour régler SQL_ATTR_ASYNC_ENABLE lorsque le SQL_ASYNC_MODE *InfoType* retourne SQL_AM_CONNECTION renvoie SQLSTATE HYC00 (fonction facultative non mise en œuvre). Pour plus d’informations, consultez [la fonction SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md) pour plus d’informations.|  
|SQL_ATTR_ASYNC_STMT_EVENT (ODBC 3.8)|Une valeur SQLPOINTER qui est une poignée d’événements.<br /><br /> La notification de l’achèvement des fonctions asynchrones est activée en appelant **SQLSetStmtAttr** pour définir **l’attribut SQL_ATTR_ASYNC_STMT_EVENT** et spécifier la poignée de l’événement.|  
|SQL_ATTR_ASYNC_STMT_PCALLBACK (ODBC 3.8)|Un SQLPOINTER à la fonction de rappel asynchrone.<br /><br /> Seul le gestionnaire de conducteur peut appeler la fonction **SQLSetStmtAttr** d’un conducteur avec cet attribut.|  
|SQL_ATTR_ASYNC_STMT_PCONTEXT (ODBC 3.8)|Un SQLPOINTER à la structure contextuelle<br /><br /> Seul le gestionnaire de conducteur peut appeler la fonction **SQLSetStmtAttr** d’un conducteur avec cet attribut.|  
|SQL_ATTR_CONCURRENCY (ODBC 2.0)|Une valeur SQLULEN qui spécifie la concordance du curseur :<br /><br /> SQL_CONCUR_READ_ONLY cursor est lu uniquement. Aucune mise à jour n’est autorisée.<br /><br /> SQL_CONCUR_LOCK cursor utilise le niveau de verrouillage le plus bas suffisant pour s’assurer que la ligne peut être mise à jour.<br /><br /> SQL_CONCUR_ROWVER - Cursor utilise un contrôle de concurrence optimiste, comparant les versions de ligne telles que SQLBase ROWID ou Sybase TIMESTAMP.<br /><br /> SQL_CONCUR_VALUES - Cursor utilise un contrôle de concurrence optimiste, comparant les valeurs.<br /><br /> La valeur par défaut pour SQL_ATTR_CONCURRENCY est SQL_CONCUR_READ_ONLY.<br /><br /> Cet attribut ne peut pas être spécifié pour un curseur ouvert. Pour plus d’informations, voir [Types de concurrency](../../../odbc/reference/develop-app/concurrency-types.md).<br /><br /> Si *l’attribut* SQL_ATTR_CURSOR_TYPE est modifié en un type qui ne supporte pas la valeur actuelle de SQL_ATTR_CONCURRENCY, la valeur de SQL_ATTR_CONCURRENCY sera modifiée au moment de l’exécution, et un avertissement émis lorsque **SQLExecDirect** ou **SQLPrepare** est appelé.<br /><br /> Si le conducteur prend en charge la déclaration **SELECT FOR UPDATE** et qu’une telle déclaration est exécutée pendant que la valeur de SQL_ATTR_CONCURRENCY est réglée pour SQL_CONCUR_READ_ONLY, une erreur sera retournée. Si la valeur de SQL_ATTR_CONCURRENCY est changée en valeur que le conducteur prend en charge pour une certaine valeur de SQL_ATTR_CURSOR_TYPE mais pas pour la valeur actuelle de SQL_ATTR_CURSOR_TYPE, la valeur de SQL_ATTR_CURSOR_TYPE sera changée au moment de l’exécution et SQLSTATE 01S02 (valeur d’option modifiée) est émise lorsque **SQLExecDirect** ou **SQLPrepare** est appelé.<br /><br /> Si la concordance spécifiée n’est pas prise en charge par la source de données, le conducteur remplace une concurrence différente et renvoie SQLSTATE 01S02 (valeur d’option modifiée). Pour SQL_CONCUR_VALUES, le conducteur remplace SQL_CONCUR_ROWVER, et vice versa. Pour SQL_CONCUR_LOCK, le conducteur remplace, dans l’ordre, SQL_CONCUR_ROWVER ou SQL_CONCUR_VALUES. La validité de la valeur substituée n’est pas vérifiée avant l’heure de l’exécution.<br /><br /> Pour plus d’informations sur la relation entre SQL_ATTR_CONCURRENCY et les autres attributs curseur, voir [Caractéristiques cursor et Type cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_SCROLLABLE (ODBC 3.0)|Une valeur SQLULEN qui spécifie le niveau de soutien dont la demande a besoin. La définition de cet attribut affecte les appels ultérieurs à **SQLExecDirect** et **SQLExecute**.<br /><br /> SQL_NONSCROLLABLE - Les curseurs défilements ne sont pas requis sur la poignée de déclaration. Si l’application appelle **SQLFetchScroll** sur cette poignée, la seule valeur valide de *FetchOrientation* est SQL_FETCH_NEXT. Il s’agit de la valeur par défaut.<br /><br /> SQL_SCROLLABLE - Curseurs défilants sont nécessaires sur la poignée de déclaration. Lorsque vous appelez **SQLFetchScroll**, l’application peut spécifier toute valeur valide de *FetchOrientation*, atteindre le positionnement cursor dans des modes autres que le mode séquentiel.<br /><br /> Pour plus d’informations sur les curseurs défilementables, voir [Cursesors défilants](../../../odbc/reference/develop-app/scrollable-cursors.md). Pour plus d’informations sur la relation entre SQL_ATTR_CURSOR_SCROLLABLE et les autres attributs du curseur, voir [Caractéristiques cursor et type de curseur](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)|  
|SQL_ATTR_CURSOR_SENSITIVITY (ODBC 3.0)|Une valeur SQLULEN qui précise si les curseurs sur la poignée de déclaration rendent visibles les modifications apportées à un résultat défini par un autre curseur. La définition de cet attribut affecte les appels ultérieurs à **SQLExecDirect** et **SQLExecute**. Une demande peut relire la valeur de cet attribut pour obtenir son état initial ou son état comme le plus récemment défini par la demande.<br /><br /> SQL_UNSPECIFIED - Il n’est pas spécifié ce que le type de curseur est et si les curseurs sur la poignée de déclaration rendent visibles les changements apportés à un résultat défini par un autre curseur. Les curseurs sur la poignée de déclaration peuvent rendre visibles aucun, certains ou tous ces changements. Il s’agit de la valeur par défaut.<br /><br /> SQL_INSENSITIVE - Tous les curseurs sur la poignée de déclaration montrent l’ensemble de résultat sans refléter les modifications apportées à elle par n’importe quel autre curseur. Les curseurs insensibles sont lus uniquement. Cela correspond à un curseur statique, qui a une concordance qui est lu seulement.<br /><br /> SQL_SENSITIVE - Tous les curseurs sur la poignée de déclaration rendent visibles toutes les modifications apportées à un résultat défini par un autre curseur.<br /><br /> Pour plus d’informations sur la relation entre SQL_ATTR_CURSOR_SENSITIVITY et les autres attributs curseur, voir [Caractéristiques cursor et Type cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_TYPE (ODBC 2.0)|Une valeur SQLULEN qui spécifie le type de curseur :<br /><br /> SQL_CURSOR_FORWARD_ONLY - Le curseur ne fait que défiler vers l’avant.<br /><br /> SQL_CURSOR_STATIC - Les données de l’ensemble de résultats sont statiques.<br /><br /> SQL_CURSOR_KEYSET_DRIVEN - Le conducteur enregistre et utilise les clés pour le nombre de lignes spécifiées dans l’attribut SQL_ATTR_KEYSET_SIZE déclaration.<br /><br /> SQL_CURSOR_DYNAMIC le conducteur enregistre et n’utilise que les clés pour les rangées dans le rame.<br /><br /> La valeur par défaut est SQL_CURSOR_FORWARD_ONLY. Cet attribut ne peut pas être précisé après la déclaration SQL a été préparé.<br /><br /> Si le type de curseur spécifié n’est pas pris en charge par la source de données, le conducteur remplace un type de curseur différent et renvoie SQLSTATE 01S02 (valeur d’option modifiée). Pour un curseur mixte ou dynamique, le conducteur remplace, dans l’ordre, un curseur statique ou à clé. Pour un curseur à clé, le conducteur remplace un curseur statique.<br /><br /> Pour plus d’informations sur les types de curseurs défilementables, voir [Les types de curseurs défilants](../../../odbc/reference/develop-app/scrollable-cursor-types.md). Pour plus d’informations sur la relation entre SQL_ATTR_CURSOR_TYPE et les autres attributs curseur, voir [Caractéristiques cursor et Type cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_ENABLE_AUTO_IPD (ODBC 3.0)|Une valeur SQLULEN qui précise si la population automatique de la DPI est effectuée :<br /><br /> SQL_TRUE - Active la population automatique de l’IPD après un appel à **SQLPrepare**. SQL_FALSE - Éteint la population automatique de l’IPD après un appel à **SQLPrepare**. (Une application peut toujours obtenir des informations sur le terrain IPD en appelant **SQLDescribeParam**, si elle est prise en charge.) La valeur par défaut de l’attribut de l’instruction SQL_ATTR_ENABLE_AUTO_IPD est SQL_FALSE. Pour plus d’informations, voir [Population automatique de l’IPD](../../../odbc/reference/develop-app/automatic-population-of-the-ipd.md).|  
|SQL_ATTR_FETCH_BOOKMARK_PTR (ODBC 3.0)|Un SQLLEN \* qui pointe vers une valeur de signet binaire. Lorsque **SQLFetchScroll** est appelé avec *fFetchOrientation* égale à SQL_FETCH_BOOKMARK, le conducteur ramasse la valeur de signet de ce domaine. Ce champ par défaut à un pointeur nul. Pour plus d’informations, voir [Scrolling by Bookmark](../../../odbc/reference/develop-app/scrolling-by-bookmark.md).<br /><br /> La valeur soulignée par ce champ n’est pas utilisée pour supprimer par signets, mise à jour par signet, ou aller chercher par les opérations de signets dans **SQLBulkOperations**, qui utilisent des signets en cache dans des tampons encastrés.|  
|SQL_ATTR_IMP_PARAM_DESC (ODBC 3.0)|Le manche de l’IPD. La valeur de cet attribut est le descripteur attribué lors de l’attribution initiale de l’énoncé. L’application ne peut pas définir cet attribut.<br /><br /> Cet attribut peut être récupéré par un appel à **SQLGetStmtAttr** mais pas réglé par un appel à **SQLSetStmtAttr**.|  
|SQL_ATTR_IMP_ROW_DESC (ODBC 3.0)|Le manche de l’IRD. La valeur de cet attribut est le descripteur attribué lors de l’attribution initiale de l’énoncé. L’application ne peut pas définir cet attribut.<br /><br /> Cet attribut peut être récupéré par un appel à **SQLGetStmtAttr** mais pas réglé par un appel à **SQLSetStmtAttr**.|  
|SQL_ATTR_KEYSET_SIZE (ODBC 2.0)|Un SQLULEN qui précise le nombre de lignes dans le jeu de clés pour un curseur à clé. Si la taille du jeu de clés est de 0 (par défaut), le curseur est entièrement piloté par un jeu de clés. Si la taille du jeu de clés est supérieure à 0, le curseur est mélangé (clé entraînée dans le jeu de clés et dynamique à l’extérieur du jeu de clés). La taille par défaut de l’ensemble de clés est de 0. Pour plus d’informations sur les curseurs pilotés par keyset, voir [Keyset-Driven Cursors](../../../odbc/reference/develop-app/keyset-driven-cursors.md).<br /><br /> Si la taille spécifiée dépasse la taille maximale de l’ensemble de clés, le conducteur remplace cette taille et renvoie SQLSTATE 01S02 (valeur d’option modifiée).<br /><br /> **SQLFetch** ou **SQLFetchScroll** renvoie une erreur si la taille du jeu de clés est supérieure à 0 et inférieure à la taille de l’aviron.|  
|SQL_ATTR_MAX_LENGTH (ODBC 1.0)|Une valeur SQLULEN qui spécifie la quantité maximale de données que le conducteur retourne d’un personnage ou d’une colonne binaire. Si *ValuePtr* est inférieur à la longueur des données disponibles, **SQLFetch** ou **SQLGetData** tronque les données et renvoie SQL_SUCCESS. Si *ValuePtr* est 0 (par défaut), le pilote tente de retourner toutes les données disponibles.<br /><br /> Si la longueur spécifiée est inférieure à la quantité minimale de données que la source de données peut retourner ou supérieure à la quantité maximale de données que la source de données peut retourner, le conducteur remplace cette valeur et retourne SQLSTATE 01S02 (valeur d’option modifiée).<br /><br /> La valeur de cet attribut peut être fixée sur un curseur ouvert; toutefois, le paramètre pourrait ne pas entrer en vigueur immédiatement, auquel cas le conducteur retournera SQLSTATE 01S02 (valeur d’option modifiée) et réinitialisera l’attribut à sa valeur d’origine.<br /><br /> Cet attribut vise à réduire le trafic réseau et ne doit être pris en charge que lorsque la source de données (par opposition au conducteur) dans un pilote à plusieurs niveaux peut l’implémenter. Ce mécanisme ne doit pas être utilisé par les applications pour tronquer les données; pour tronquer les données reçues, une demande doit spécifier la longueur maximale du tampon dans l’argument *De BufferLength* dans **SQLBindCol** ou **SQLGetData**.|  
|SQL_ATTR_MAX_ROWS (ODBC 1.0)|Une valeur SQLULEN correspondant au nombre maximum de lignes pour revenir à la demande de relevé **SELECT.** Si \* *ValuePtr* est égal à 0 (la valeur par défaut), le pilote renvoie toutes les lignes.<br /><br /> Cet attribut vise à réduire le trafic réseau. Conceptuellement, il est appliqué lorsque l’ensemble de résultat est créé et limite le résultat fixé aux premières lignes *ValuePtr.* Si le nombre de lignes dans l’ensemble de résultat est supérieur à *ValuePtr*, l’ensemble de résultat est tronqué.<br /><br /> SQL_ATTR_MAX_ROWS s’applique à tous les ensembles de résultats de *l’Énoncé,* y compris ceux retournés par les fonctions du catalogue. SQL_ATTR_MAX_ROWS établit un maximum pour la valeur du nombre de rangées de curseurs.<br /><br /> Un conducteur ne doit pas imiter SQL_ATTR_MAX_ROWS comportement pour **SQLFetch** ou **SQLFetchScroll** (si les limites de taille de l’ensemble des résultats ne peuvent pas être mises en œuvre à la source de données) s’il ne peut garantir que SQL_ATTR_MAX_ROWS sera mis en œuvre correctement.<br /><br /> Il est défini par le conducteur si SQL_ATTR_MAX_ROWS s’applique à des énoncés autres que les relevés SELECT (tels que les fonctions de catalogue).<br /><br /> La valeur de cet attribut peut être fixée sur un curseur ouvert; toutefois, le paramètre pourrait ne pas entrer en vigueur immédiatement, auquel cas le conducteur retournera SQLSTATE 01S02 (valeur d’option modifiée) et réinitialisera l’attribut à sa valeur d’origine.|  
|SQL_ATTR_METADATA_ID (ODBC 3.0)|Une valeur SQLULEN qui détermine la façon dont les arguments de chaîne des fonctions du catalogue sont traités.<br /><br /> Si SQL_TRUE, l’argument de chaîne des fonctions de catalogue est traité comme des identificateurs. L’affaire n’est pas importante. Pour les cordes non-démocratiques, le conducteur enlève tous les espaces de fuite et la corde est pliée à la majuscule. Pour les cordes délimitées, le conducteur enlève tous les espaces de tête ou de fuite et prend tout ce qui est entre les délimitations littéralement. Si l’un de ces arguments est réglé sur un pointeur nul, la fonction renvoie SQL_ERROR et SQLSTATE HY009 (utilisation invalide du pointeur nul).<br /><br /> Si SQL_FALSE, les arguments de chaîne des fonctions de catalogue ne sont pas traités comme des identificateurs. L’affaire est importante. Ils peuvent contenir soit un modèle de recherche de cordes ou non, selon l’argument.<br /><br /> La valeur par défaut est SQL_FALSE.<br /><br /> *L’argument de TableType* de **SQLTables**, qui prend une liste de valeurs, n’est pas affecté par cet attribut.<br /><br /> SQL_ATTR_METADATA_ID peut également être fixé au niveau de connexion. (Il et SQL_ATTR_ASYNC_ENABLE sont les seuls attributs de déclaration qui sont également attributs de connexion.)<br /><br /> Pour plus d’informations, voir [Arguments in Catalog Functions](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).|  
|SQL_ATTR_NOSCAN (ODBC 1.0)|Une valeur SQLULEN qui indique si le conducteur doit scanner les cordes SQL pour les séquences d’évacuation :<br /><br /> SQL_NOSCAN_OFF - Le conducteur scanne les chaînes SQL pour les séquences d’évacuation (par défaut).<br /><br /> SQL_NOSCAN_ON - Le conducteur ne scanne pas les cordes SQL pour les séquences d’évacuation. Au lieu de cela, le conducteur envoie la déclaration directement à la source de données.<br /><br /> Pour plus d’informations, voir [Escape Sequences in ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md).|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR (ODBC 3.0)|Une valeur SQLULEN qui indique une compensation ajoutée aux pointeurs pour changer la fixation des paramètres dynamiques. Si ce champ n’est pas nul, le conducteur déduise le pointeur, ajoute la valeur déreférée à chacun des champs différés dans l’enregistrement du descripteur (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR et SQL_DESC_OCTET_LENGTH_PTR), et utilise les nouvelles valeurs de pointeur lors de la liaison. Il est configuré à null par défaut.<br /><br /> Le décalage de liaison est toujours ajouté directement aux champs SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR et SQL_DESC_OCTET_LENGTH_PTR. Si le décalage est modifié à une valeur différente, la nouvelle valeur est toujours ajoutée directement à la valeur dans le champ descripteur. Le nouveau décalage n’est pas ajouté à la valeur du champ plus des compensations antérieures.<br /><br /> Pour plus d’informations, voir [Paramètre Binding Offsets](../../../odbc/reference/develop-app/parameter-binding-offsets.md).<br /><br /> La définition de cet attribut d’instruction définit le champ SQL_DESC_BIND_OFFSET_PTR dans l’en-tête APD.|  
|SQL_ATTR_PARAM_BIND_TYPE (ODBC 3.0)|Une valeur SQLULEN qui indique l’orientation de liaison à utiliser pour les paramètres dynamiques.<br /><br /> Ce champ est configuré pour SQL_PARAM_BIND_BY_COLUMN (par défaut) pour sélectionner la liaison de colonne-sage.<br /><br /> Pour sélectionner la fixation en ligne, ce champ est réglé sur la longueur de la structure ou à l’exemple d’un tampon qui sera lié à un ensemble de paramètres dynamiques. Cette longueur doit inclure de l’espace pour tous les paramètres liés et tout rembourrage de la structure ou du tampon pour s’assurer que lorsque l’adresse d’un paramètre lié est incrémentée avec la longueur spécifiée, le résultat indiquera le début du même paramètre dans le prochain ensemble de paramètres. Lors de *l’utilisation de la taille de l’opérateur* dans ANSI C, ce comportement est garanti.<br /><br /> Pour plus d’informations, voir [Binding Arrays of Parameters](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).<br /><br /> La définition de cet attribut d’énoncé définit le champ SQL_DESC_ BIND_TYPE dans l’en-tête APD.|  
|SQL_ATTR_PARAM_OPERATION_PTR (ODBC 3.0)|Une valeur SQLUSMALLINT \* qui indique un éventail de valeurs SQLUSMALLINT utilisées pour ignorer un paramètre lors de l’exécution d’une déclaration SQL. Chaque valeur est réglée soit sur SQL_PARAM_PROCEED (pour que le paramètre soit exécuté) ou SQL_PARAM_IGNORE (pour que le paramètre soit ignoré).<br /><br /> Un ensemble de paramètres peut être ignoré pendant le traitement en définissant la valeur de statut dans le tableau pointé par SQL_DESC_ARRAY_STATUS_PTR dans la DPA à SQL_PARAM_IGNORE. Un ensemble de paramètres est traité si sa valeur de statut est définie pour SQL_PARAM_PROCEED ou si aucun élément du tableau n’est défini.<br /><br /> Cet attribut d’instruction peut être réglé à un pointeur nul, auquel cas le conducteur ne retourne pas les valeurs de statut de paramètre. Cet attribut peut être défini à tout moment, mais la nouvelle valeur n’est pas utilisée avant la prochaine fois **que SQLExecDirect** ou **SQLExecute** est appelé.<br /><br /> Cet attribut est ignoré lorsqu’il n’y a pas de paramètre lié.<br /><br /> Pour plus d’informations, voir [Utiliser des tableaux de paramètres](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> La définition de cet attribut d’instruction définit le champ SQL_DESC_ARRAY_STATUS_PTR dans l’en-tête APD.|  
|SQL_ATTR_PARAM_STATUS_PTR (ODBC 3.0)|Une valeur SQLUSMALLINT \* qui indique un éventail de valeurs SQLUSMALLINT contenant des informations sur l’état pour chaque rangée de valeurs de paramètres après un appel à **SQLExecute** ou **SQLExecDirect**. Ce champ n’est nécessaire que si PARAMSET_SIZE est supérieur à 1.<br /><br /> Les valeurs de statut peuvent contenir les valeurs suivantes :<br /><br /> SQL_PARAM_SUCCESS : La déclaration sqL a été exécutée avec succès pour cet ensemble de paramètres.<br /><br /> SQL_PARAM_SUCCESS_WITH_INFO : La déclaration de SQL a été exécutée avec succès pour cet ensemble de paramètres; cependant, des informations d’avertissement sont disponibles dans la structure de données de diagnostic.<br /><br /> SQL_PARAM_ERROR : Il y a eu une erreur dans le traitement de cet ensemble de paramètres. Des informations supplémentaires sur les erreurs sont disponibles dans la structure de données de diagnostic.<br /><br /> SQL_PARAM_UNUSED : Cet ensemble de paramètres n’a pas été utilisé, peut-être en raison du fait qu’un ensemble de paramètres antérieur a causé une erreur qui a avorté davantage de traitement, ou parce que SQL_PARAM_IGNORE a été défini pour cet ensemble de paramètres dans le tableau spécifié par le SQL_ATTR_PARAM_OPERATION_PTR.<br /><br /> SQL_PARAM_DIAG_UNAVAILABLE: Le conducteur traite des tableaux de paramètres comme une unité monolithique et ne génère donc pas ce niveau d’informations d’erreur.<br /><br /> Cet attribut d’instruction peut être réglé à un pointeur nul, auquel cas le conducteur ne retourne pas les valeurs de statut de paramètre. Cet attribut peut être défini à tout moment, mais la nouvelle valeur n’est pas utilisée avant la prochaine fois **que SQLExecute** ou **SQLExecDirect** est appelé. Notez que le réglage de cet attribut peut affecter le comportement de paramètre de sortie mis en œuvre par le pilote.<br /><br /> Pour plus d’informations, voir [Utiliser des tableaux de paramètres](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> La définition de cet attribut d’instruction définit le champ SQL_DESC_ARRAY_STATUS_PTR dans l’en-tête IPD.|  
|SQL_ATTR_PARAMS_PROCESSED_PTR (ODBC 3.0)|Un champ \* de dossiers SQLULEN qui indique un tampon dans lequel retourner le nombre d’ensembles de paramètres qui ont été traités, y compris les ensembles d’erreurs. Aucun numéro ne sera retourné s’il s’agit d’un pointeur nul.<br /><br /> La définition de cet attribut d’instruction définit le champ SQL_DESC_ROWS_PROCESSED_PTR dans l’en-tête IPD.<br /><br /> Si l’appel à **SQLExecDirect** ou **SQLExecute** qui remplit le tampon pointé par cet attribut ne renvoie pas SQL_SUCCESS ou SQL_SUCCESS_WITH_INFO, le contenu du tampon n’est pas défini.<br /><br /> Pour plus d’informations, voir [Utiliser des tableaux de paramètres](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).|  
|SQL_ATTR_PARAMSET_SIZE (ODBC 3.0)|Une valeur SQLULEN qui précise le nombre de valeurs pour chaque paramètre. Si SQL_ATTR_PARAMSET_SIZE est supérieure à 1, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR et SQL_DESC_OCTET_LENGTH_PTR du point APD aux tableaux. La cardinalité de chaque tableau est égale à la valeur de ce domaine.<br /><br /> Cet attribut est ignoré lorsqu’il n’y a pas de paramètre lié.<br /><br /> Pour plus d’informations, voir [Utiliser des tableaux de paramètres](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> La définition de cet attribut d’instruction définit le champ SQL_DESC_ARRAY_SIZE dans l’en-tête APD.|  
|SQL_ATTR_QUERY_TIMEOUT (ODBC 1.0)|Une valeur SQLULEN correspondant au nombre de secondes à exécuter avant de revenir à l’application. Si *ValuePtr* est égal à 0 (par défaut), il n’y a pas de délai d’attente.<br /><br /> Si le délai d’attente spécifié dépasse le délai d’attente maximal dans la source de données ou est inférieur au délai minimum, **SQLSetStmtAttr** remplace cette valeur et retourne SQLSTATE 01S02 (valeur d’option modifiée).<br /><br /> Notez que l’application n’a pas besoin d’appeler **SQLCloseCursor** pour réutiliser l’instruction si une déclaration **SELECT** a été chronométrée.<br /><br /> Le délai d’attente de requête défini dans cet attribut de déclaration est valide en mode synchrone et asynchrone.|  
|SQL_ATTR_RETRIEVE_DATA (ODBC 2.0)|Une valeur SQLULEN :<br /><br /> SQL_RD_ON **SQLFetchScroll** et, dans ODBC *3.x*, **SQLFetch** récupérer des données après avoir positionné le curseur à l’endroit spécifié. Il s’agit de la valeur par défaut.<br /><br /> SQL_RD_OFF **SQLFetchScroll** et, dans ODBC *3.x*, **SQLFetch** ne récupèrent pas les données après avoir positionné le curseur.<br /><br /> En définissant SQL_RETRIEVE_DATA pour SQL_RD_OFF, une application peut vérifier qu’une ligne existe ou récupérer un signet pour la ligne sans encourir les frais généraux de récupération des rangées. Pour plus d’informations, voir [Scrolling and Fetching Rows](../../../odbc/reference/develop-app/scrolling-and-fetching-rows-odbc.md).<br /><br /> La valeur de cet attribut peut être fixée sur un curseur ouvert; toutefois, le paramètre pourrait ne pas entrer en vigueur immédiatement, auquel cas le conducteur retournera SQLSTATE 01S02 (valeur d’option modifiée) et réinitialisera l’attribut à sa valeur d’origine.|  
|SQL_ATTR_ROW_ARRAY_SIZE (ODBC 3.0)|Une valeur SQLULEN qui précise le nombre de rangées retournées par chaque appel à **SQLFetch** ou **SQLFetchScroll**. C’est aussi le nombre de lignes dans un tableau de signets utilisé dans une opération de signets en vrac dans **SQLBulkOperations**. La valeur par défaut est 1.<br /><br /> Si la taille spécifiée de l’acart dépasse la taille maximale de l’ensemble de rangées supportée par la source de données, le conducteur remplace cette valeur et retourne SQLSTATE 01S02 (valeur d’option modifiée).<br /><br /> Pour plus d’informations, voir [Rowset Size](../../../odbc/reference/develop-app/rowset-size.md).<br /><br /> La définition de cet attribut d’instruction définit le champ SQL_DESC_ARRAY_SIZE dans l’en-tête ARD.|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR (ODBC 3.0)|Une valeur SQLULEN qui indique une compensation ajoutée aux pointeurs pour modifier la fixation des données de colonne. Si ce champ n’est pas nul, le conducteur déduise le pointeur, ajoute la valeur déreférée à chacun des champs différés dans l’enregistrement du descripteur (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR et SQL_DESC_OCTET_LENGTH_PTR), et utilise les nouvelles valeurs de pointeur lors de la liaison. Il est configuré à null par défaut.<br /><br /> La définition de cet attribut d’instruction définit le champ SQL_DESC_BIND_OFFSET_PTR dans l’en-tête ARD.|  
|SQL_ATTR_ROW_BIND_TYPE (ODBC 1.0)|Une valeur SQLULEN qui définit l’orientation contraignante à utiliser lorsque **SQLFetch** ou **SQLFetchScroll** est appelé sur la déclaration associée. La liaison de la colonne est sélectionnée en définissant la valeur à SQL_BIND_BY_COLUMN. La fixation en ligne est choisie en définissant la valeur à la longueur d’une structure ou à une instance d’un tampon dans lequel les colonnes de résultat seront liées.<br /><br /> Si une longueur est spécifiée, elle doit inclure de l’espace pour toutes les colonnes liées et tout rembourrage de la structure ou du tampon pour s’assurer que lorsque l’adresse d’une colonne liée est incrémentée avec la longueur spécifiée, le résultat indiquera le début de la même colonne dans la rangée suivante. Lorsque vous utilisez la **taille de l’opérateur** avec des structures ou des syndicats dans ANSI C, ce comportement est garanti.<br /><br /> La liaison de colonne-sage est l’orientation de liaison par défaut pour **SQLFetch** et **SQLFetchScroll**.<br /><br /> Pour plus d’informations, voir [Colonnes de liaison pour l’utilisation avec les curseurs de bloc](../../../odbc/reference/develop-app/binding-columns-for-use-with-block-cursors.md).<br /><br /> La définition de cet attribut d’instruction définit le champ SQL_DESC_BIND_TYPE dans l’en-tête ARD.|  
|SQL_ATTR_ROW_NUMBER (ODBC 2.0)|Une valeur SQLULEN qui est le nombre de la rangée actuelle dans l’ensemble de l’ensemble des résultats. Si le nombre de la rangée actuelle ne peut pas être déterminé ou qu’il n’y a pas de ligne actuelle, le conducteur retourne 0.<br /><br /> Cet attribut peut être récupéré par un appel à **SQLGetStmtAttr** mais pas réglé par un appel à **SQLSetStmtAttr**.|  
|SQL_ATTR_ROW_OPERATION_PTR (ODBC 3.0)|Une valeur SQLUSMALLINT \* qui indique un éventail de valeurs SQLUSMALLINT utilisées pour ignorer une ligne lors d’une opération en vrac à l’aide de **SQLSetPos**. Chaque valeur est réglée soit sur SQL_ROW_PROCEED (pour que la ligne soit incluse dans l’opération en vrac) ou SQL_ROW_IGNORE (pour que la rangée soit exclue de l’opération en vrac). (Les lignes ne peuvent pas être ignorées en utilisant ce tableau lors des appels à **SQLBulkOperations**.)<br /><br /> Cet attribut de déclaration peut être réglé à un pointeur nul, auquel cas le conducteur ne retourne pas les valeurs de statut de ligne. Cet attribut peut être défini à tout moment, mais la nouvelle valeur n’est pas utilisée avant la prochaine fois **que SQLSetPos** est appelé.<br /><br /> Pour plus d’informations, voir [Updating Rows in the Rowset with SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md) and [Deleting Rows in the Rowset with SQLSetPos](../../../odbc/reference/develop-app/deleting-rows-in-the-rowset-with-sqlsetpos.md).<br /><br /> La définition de cet attribut d’énoncé définit le champ SQL_DESC_ARRAY_STATUS_PTR dans l’ARD.|  
|SQL_ATTR_ROW_STATUS_PTR (ODBC 3.0)|Une valeur SQLUSMALLINT \* qui indique un éventail de valeurs SQLUSMALLINT contenant des valeurs d’état de ligne après un appel à **SQLFetch** ou **SQLFetchScroll**. Le tableau a autant d’éléments qu’il ya des rangées dans le rowset.<br /><br /> Cet attribut de déclaration peut être réglé à un pointeur nul, auquel cas le conducteur ne retourne pas les valeurs de statut de ligne. Cet attribut peut être défini à tout moment, mais la nouvelle valeur n’est pas utilisée avant la prochaine fois **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll**, ou **SQLSetPos** est appelé.<br /><br /> Pour plus d’informations, voir [Nombre de lignes récupérées et statut](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> La définition de cet attribut de déclaration définit le champ SQL_DESC_ARRAY_STATUS_PTR dans l’en-tête de l’IRD.<br /><br /> Cet attribut est cartographié par un pilote ODBC *2.x* au tableau *rgbRowStatus* dans un appel à **SQLExtendedFetch**.|  
|SQL_ATTR_ROWS_FETCHED_PTR (ODBC 3.0)|Une valeur \* SQLULEN qui indique un tampon dans lequel retourner le nombre de rangées récupérées après un appel à **SQLFetch** ou **SQLFetchScroll;** le nombre de lignes touchées par une opération en vrac effectuée par un appel à **SQLSetPos** avec un argument *d’opération* de SQL_REFRESH; ou le nombre de rangées touchées par une opération en vrac effectuée par **SQLBulkOperations**. Ce nombre comprend les lignes d’erreur.<br /><br /> Pour plus d’informations, voir [Nombre de lignes récupérées et statut](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> La définition de cet attribut de déclaration définit le champ SQL_DESC_ROWS_PROCESSED_PTR dans l’en-tête de l’IRD.<br /><br /> Si l’appel à **SQLFetch** ou **SQLFetchScroll** qui remplit le tampon pointé par cet attribut ne renvoie pas SQL_SUCCESS ou SQL_SUCCESS_WITH_INFO, le contenu du tampon n’est pas défini.|  
|SQL_ATTR_SIMULATE_CURSOR (ODBC 2.0)|Une valeur SQLULEN qui précise si les conducteurs qui simulent les mises à jour positionnées et suppriment les déclarations garantissent que ces déclarations n’affectent qu’une seule rangée.<br /><br /> Pour simuler les mises à jour positionnées et supprimer les déclarations, la plupart des pilotes construisent une mise **À JOUR** recherchée ou une déclaration **DELETE** contenant une clause **WHERE** qui spécifie la valeur de chaque colonne dans la rangée actuelle. À moins que ces colonnes ne constituent une clé unique, une telle déclaration peut affecter plus d’une rangée.<br /><br /> Pour garantir que ces déclarations n’affectent qu’une seule ligne, le pilote détermine les colonnes dans une touche unique et ajoute ces colonnes à l’ensemble de résultats. Si une application garantit que les colonnes dans le résultat configurent une clé unique, le conducteur n’est pas tenu de le faire. Cela peut réduire le temps d’exécution.<br /><br /> SQL_SC_NON_UNIQUE - Le conducteur ne garantit pas que la mise à jour ou la suppression simulées des déclarations de mise à jour ou de suppression n’affecteront qu’une seule rangée; il incombe à l’application de le faire. Si une déclaration touche plus d’une rangée, **SQLExecute**, **SQLExecDirect**, ou **SQLSetPos** retourne SQLSTATE 01001 (conflit d’opération Cursor).<br /><br /> SQL_SC_TRY_UNIQUE - Le conducteur tente de garantir que la mise à jour ou la suppression simulées des déclarations de mise à jour ou de suppression n’affectent qu’une seule rangée. Le conducteur exécute toujours de telles déclarations, même si elles peuvent affecter plus d’une rangée, par exemple lorsqu’il n’y a pas de clé unique. Si une déclaration touche plus d’une rangée, **SQLExecute**, **SQLExecDirect**, ou **SQLSetPos** retourne SQLSTATE 01001 (conflit d’opération Cursor).<br /><br /> SQL_SC_UNIQUE - Le conducteur garantit que les mises à jour ou supprimer les déclarations simulées de position n’affectent qu’une seule rangée. Si le conducteur ne peut pas le garantir pour une déclaration donnée, **SQLExecDirect** ou **SQLPrepare renvoie** une erreur.<br /><br /> Si la source de données fournit un support SQL natif pour les mises à jour positionnées et supprimer les déclarations et le conducteur ne simule pas les curseurs, SQL_SUCCESS est retourné lorsque SQL_SC_UNIQUE est demandé pour SQL_SIMULATE_CURSOR. SQL_SUCCESS_WITH_INFO est retourné si SQL_SC_TRY_UNIQUE ou SQL_SC_NON_UNIQUE est demandé. Si la source de données fournit le niveau de SQL_SC_TRY_UNIQUE de soutien et le conducteur ne le fait pas, SQL_SUCCESS est retourné pour SQL_SC_TRY_UNIQUE et SQL_SUCCESS_WITH_INFO est retourné pour SQL_SC_NON_UNIQUE.<br /><br /> Si le type de simulation de curseur spécifié n’est pas pris en charge par la source de données, le conducteur remplace un type de simulation différent et renvoie SQLSTATE 01S02 (valeur d’option modifiée). Pour SQL_SC_UNIQUE, le conducteur remplace, dans l’ordre, SQL_SC_TRY_UNIQUE ou SQL_SC_NON_UNIQUE. Pour SQL_SC_TRY_UNIQUE, le conducteur remplace SQL_SC_NON_UNIQUE.<br /><br /> La valeur par défaut est SQL_SC_UNIQUE.<br /><br /> Pour plus d’informations, voir [La mise à jour positionnée Simulating et supprimer les déclarations](../../../odbc/reference/develop-app/simulating-positioned-update-and-delete-statements.md).|  
|SQL_ATTR_USE_BOOKMARKS (ODBC 2.0)|Une valeur SQLULEN qui précise si une application utilisera des signets avec un curseur :<br /><br /> SQL_UB_OFF off (la valeur par défaut)<br /><br /> SQL_UB_VARIABLE une application utilisera des signets avec un curseur, et le conducteur fournira des signets de longueur variable s’ils sont pris en charge. SQL_UB_FIXED est dépréciée dans ODBC *3.x*. Les applications ODBC *3.x* doivent toujours utiliser des signets à longueur variable, même lorsqu’elles travaillent avec des pilotes ODBC *2.x* (qui ne supportaient que les signets fixes de 4-byte). C’est parce qu’un signet fixe est juste un cas spécial d’un signet à longueur variable. Lorsque vous travaillez avec un pilote ODBC *2.x,* le Driver Manager SQL_UB_VARIABLE à SQL_UB_FIXED.<br /><br /> Pour utiliser des signets avec un curseur, l’application doit spécifier cet attribut avec la valeur SQL_UB_VARIABLE avant d’ouvrir le curseur.<br /><br /> Pour plus d’informations, voir [Retrieving Bookmarks](../../../odbc/reference/develop-app/retrieving-bookmarks.md).|  
  
 [1] Ces fonctions ne peuvent être appelées asynchronement que si le descripteur est un descripteur de mise en œuvre, et non un descripteur d’application.  
  
 Voir [Column-Wise Binding](../../../odbc/reference/develop-app/column-wise-binding.md) et [Row-Wise Binding](../../../odbc/reference/develop-app/row-wise-binding.md).  
  
## <a name="related-functions"></a>Fonctions connexes  
  
|Pour obtenir des informations sur|Consultez|  
|---------------------------|---------|  
|Annulation du traitement des relevés|[SQLCancel, fonction](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Retour du paramètre d’un attribut de connexion|[Fonction SQLGetConnectAttr](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Retour du paramètre d’un attribut de déclaration|[Fonction SQLGetStmtAttr](../../../odbc/reference/syntax/sqlgetstmtattr-function.md)|  
|Définir un attribut de connexion|[Fonction SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|Réglage d’un champ unique du descripteur|[SQLSetDescField, fonction](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
  
## <a name="see-also"></a>Voir aussi  
 [Référence API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Fichiers d’en-tête ODBC](../../../odbc/reference/install/odbc-header-files.md)
