---
title: Ce que fait le gestionnaire de chauffeurs Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- driver manager [ODBC], backward compatibility
- compatibility [ODBC], driver manager
- ODBC driver manager [ODBC]
- backward compatibility [ODBC], driver manager
ms.assetid: 57f65c38-d9ee-46c8-9051-128224a582c6
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 07ab0784e6f6ad4487a02a179a5fa3be2617c930
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/14/2020
ms.locfileid: "81306560"
---
# <a name="what-the-driver-manager-does"></a>Ce que fait le gestionnaire de pilotes
Le tableau suivant résume comment l’ODBC *3.x* Driver Manager cartographie les appels aux pilotes ODBC *2.x* et ODBC *3.x.*  
  
|Fonction ou<br /><br /> attribut d'instruction|Commentaires|  
|-----------------------------------------|--------------|  
|SQL_ATTR_FETCH_BOOKMARK_PTR|Points au signet à utiliser avec **SQLFetchScroll**. Voici les détails de la mise en œuvre :<br /><br /> - Lorsqu’une application l’installe dans un pilote ODBC *2.x,* l’ODBC *3.x* Driver Manager le cache. Il déduise le pointeur et transmet la valeur au conducteur ODBC *2.x* dans l’argument *FetchOffset* de **SQLExtendedFetch** lorsque **SQLFetchScroll** est plus tard appelé par la demande.<br />- Lorsqu’une application place cela dans un pilote ODBC *3.x,* l’ODBC *3.x* Driver Manager passe l’appel au conducteur.|  
|SQL_ATTR_ROW_STATUS_PTR|Points à la ligne de classement rempli par **SQLFetch**, **SQLFetchScroll**, **SQLBulkOperations**, et **SQLSetPos**. Voici les détails de la mise en œuvre :<br /><br /> - Lorsqu’une application place cela dans un pilote ODBC *2.x,* l’ODBC *3.x* Driver Manager cache sa valeur. Il transmet cette valeur au conducteur ODBC *2.x* dans l’argument *RowStatusArray* de **SQLExtendedFetch** lorsque **SQLFetchScroll** ou **SQLFetch** est appelé.<br />- Lorsqu’une application place cela dans un pilote ODBC *3.x,* l’ODBC *3.x* Driver Manager passe l’appel au conducteur.<br />- Dans l’état S6, si une application fixe SQL_ATTR_ROW_STATUS_PTR puis appelle **SQLBulkOperations** (avec une *opération* de SQL_ADD) ou **SQLSetPos** sans d’abord appeler **SQLFetch** ou **SQLFetchScroll**, SQLSTATE HY011 (Attribut ne peut pas être fixé maintenant) est retourné.|  
|SQL_ATTR_ROWS_FETCHED_PTR|Indique le tampon dans lequel **SQLFetch** et **SQLFetchScroll** retournent le nombre de rangées récupérées. Voici les détails de la mise en œuvre :<br /><br /> - Lorsqu’une application place cela dans un pilote ODBC *2.x,* l’ODBC *3.x* Driver Manager cache sa valeur. Il transmet cette valeur au conducteur ODBC *2.x* dans l’argument *RowCountPtr* de **SQLExtendedFetch** lorsque **SQLFetch** ou **SQLFetchScroll** est appelé par la demande.<br />- Lorsqu’une application place cela dans un pilote ODBC *3.x,* l’ODBC *3.x* Driver Manager passe l’appel au conducteur.|  
|SQL_ATTR_ROW_ARRAY_SIZE|Définit la taille de l’aviron. Voici les détails de la mise en œuvre :<br /><br /> - Lorsqu’une application l’établit dans un pilote ODBC *2.x,* l’ODBC *3.x* Driver Manager le cartographie à l’attribut SQL_ROWSET_SIZE énoncé.<br />- Lorsqu’une application place cela dans un pilote ODBC *3.x,* l’ODBC *3.x* Driver Manager passe l’appel au conducteur.<br />- Lorsqu’une application travaillant avec un conducteur ODBC *3.x* appelle **SQLSetScrollOptions**, SQL_ROWSET_SIZE est réglé à la valeur dans *l’argument RowsetSize* si le conducteur sous-jacent ne prend pas en charge **SQLSetScrollOptions**.|  
|SQL_ROWSET_SIZE|Définit la taille de l’aviron utilisée par **SQLExtendedFetch** lorsque **SQLExtendedFetch** est appelé par une application ODBC *2.x.* Voici les détails de la mise en œuvre :<br /><br /> - Lorsqu’une application définit cela, le gestionnaire de conducteur ODBC *3.x* passe l’appel au pilote, quelle que soit la version du conducteur.<br />- Lorsqu’une application travaillant avec un conducteur ODBC *2.x* appelle **SQLSetScrollOptions**, SQL_ROWSET_SIZE est réglé à la valeur dans l’argument **RowsetSize.**|  
|**SQLBulkOperations (SQLBulkOperations)**|Effectue une opération d’insertion, ou mise à jour, supprimer ou aller chercher par des opérations de signet. Voici les détails de la mise en œuvre :<br /><br /> - Lorsqu’une application appelle **SQLBulkOperations** avec une *opération* de SQL_ADD dans un conducteur ODBC *2.x,* l’ODBC *3.x* Driver Manager le cartographie à **SQLSetPos** avec une *opération* de SQL_ADD.<br />- Lorsqu’il travaille avec un conducteur ODBC *2.x* qui ne prend pas en charge **SQLSetPos** avec une *opération* de SQL_ADD, l’ODBC *3.x* Driver Manager ne cartographie pas **SQLSetPos** avec une *opération* de SQL_ADD à **SQLBulkOperations** avec une *opération* de SQL_ADD. C’est parce que **SQLBulkOperations** ne peut pas être appelé dans l’état S7, qui dans ODBC *2.x* était le seul état dans lequel **SQLSetPos** pourrait être appelé.<br />- Si l’application appelle **SQLBulkOperations** avec une *opération* de SQL_ADD dans un conducteur ODBC *2.x* avant d’appeler **SQLFetchScroll**, l’ODBC *3.x* Driver Manager renvoie une erreur.|  
|**SQLExtendedFetch**|Retourne le jeu de ligne spécifié. À l’exception de la restriction qui vient d’être mentionnée, le gestionnaire de conducteur ODBC *3.x* passe des appels au **sqLExtendedFetch** au conducteur, quelle que soit la version du conducteur.|  
|**SQLFetch**|Retourne le jeu de ligne suivant. Voici les détails de la mise en œuvre :<br /><br /> - Lorsqu’une application appelle **SQLFetch** dans un conducteur ODBC *2.x,* l’ODBC *3.x* Driver Manager la cartographie à **SQLExtendedFetch**. *L’argument de l’orientation de* **SQLExtendedFetch** est prêt à SQL_FETCH_NEXT. Le gestionnaire de conducteur utilise la valeur mise en cache de l’attribut de déclaration SQL_ATTR_ROW_STATUS_PTR pour l’argument *RowStatusArray* et la valeur mise en cache de l’attribut de déclaration SQL_ATTR_ROWS_FETCHED_PTR pour l’argument *RowCountPtr.*<br />- Une application ODBC *3.x* peut mélanger les appels à **SQLFetch** et **SQLFetchScroll** dans un pilote ODBC *2.x* parce que l’ODBC *3.x* Driver Manager cartes **SQLFetch** à **SQLExtendedFetch** quand une application l’appelle dans un pilote ODBC *2.x.*<br />- Si un conducteur ODBC *2.x* ne prend pas en charge **SQLExtendedFetch**, le gestionnaire de conducteur ODBC *3.x* ne carte pas **SQLFetch** ou **SQLFetchScroll** à **SQLExtendedFetch** lorsqu’une demande l’appelle dans ce conducteur. Si l’application tente de définir SQL_ATTR_ROW_ARRAY_SIZE à une valeur supérieure à 1, SQLSTATE HYC00 (fonction facultative non implémentée) est retournée.<br />- À l’exception des restrictions que vient de remarquer le gestionnaire de conducteur ODBC *3.x* passe des appels à **SQLFetch** au conducteur, quelle que soit la version du conducteur.|  
|**SQLFetchScroll**|Retourne le jeu de ligne spécifié. Voici les détails de la mise en œuvre :<br /><br /> - Lorsqu’une application appelle **SQLFetchScroll** dans un conducteur ODBC *2.x,* l’ODBC *3.x* Driver Manager la cartographie à **SQLExtendedFetch**. Il utilise la valeur mise en cache de l’attribut de déclaration SQL_ATTR_ROW_STATUS_PTR pour l’argument *RowStatusArray* et la valeur mise en cache de l’attribut de déclaration SQL_ATTR_ROWS_FETCHED_PTR pour l’argument *RowCountPtr.* Si l’argument *de FetchOrientation* dans **SQLFetchScroll** est SQL_FETCH_BOOKMARK, il utilise la valeur mise en cache de l’attribut de déclaration SQL_ATTR_FETCH_BOOKMARK_PTR pour l’argument *FetchOffset* et renvoie une erreur si *l’argument fetchOffset* de **SQLFetchScroll** n’est pas 0.<br />- Lorsqu’une demande l’appelle dans un pilote ODBC *3.x,* l’ODBC *3.x* Driver Manager passe l’appel au conducteur.|  
|**SQLSetPos**|Effectue diverses opérations positionnées. L’ODBC *3.x* Driver Manager transmet les appels à **SQLSetPos** au conducteur, quelle que soit la version du conducteur.|  
|**SQLSetScrollOptions**|Lorsque le gestionnaire de chauffeur cartes **SQLSetScrollOptions** pour une application de travail avec un pilote ODBC *3.x* qui ne prend pas en charge **SQLSetScrollOptions**, le gestionnaire de conducteur définit l’option de déclaration SQL_ROWSET_SIZE, et non l’attribut de déclaration SQL_ATTR_ROW_ARRAY_SIZE, à l’argument *RowsetSize* dans **SQLSetScrollOption**. Par conséquent, **SQLSetScrollOptions** ne peut pas être utilisé par une application lorsqu’il s’agit d’aller chercher plusieurs rangées par un appel à **SQLFetch** ou **SQLFetchScroll**. Il ne peut être utilisé que lorsque vous allez chercher plusieurs rangées par un appel à **SQLExtendedFetch**.|
